<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/callnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  28 #include &quot;compiler/oopMap.hpp&quot;
  29 #include &quot;gc/shared/barrierSet.hpp&quot;
  30 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;opto/callGenerator.hpp&quot;
  33 #include &quot;opto/callnode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/convertnode.hpp&quot;
  36 #include &quot;opto/escape.hpp&quot;
  37 #include &quot;opto/locknode.hpp&quot;
  38 #include &quot;opto/machnode.hpp&quot;
  39 #include &quot;opto/matcher.hpp&quot;
  40 #include &quot;opto/parse.hpp&quot;
  41 #include &quot;opto/regalloc.hpp&quot;
  42 #include &quot;opto/regmask.hpp&quot;
  43 #include &quot;opto/rootnode.hpp&quot;
  44 #include &quot;opto/runtime.hpp&quot;
  45 #include &quot;utilities/powerOfTwo.hpp&quot;
  46 
  47 // Portions of code courtesy of Clifford Click
  48 
  49 // Optimization - Graph Style
  50 
  51 //=============================================================================
  52 uint StartNode::size_of() const { return sizeof(*this); }
  53 bool StartNode::cmp( const Node &amp;n ) const
  54 { return _domain == ((StartNode&amp;)n)._domain; }
  55 const Type *StartNode::bottom_type() const { return _domain; }
  56 const Type* StartNode::Value(PhaseGVN* phase) const { return _domain; }
  57 #ifndef PRODUCT
  58 void StartNode::dump_spec(outputStream *st) const { st-&gt;print(&quot; #&quot;); _domain-&gt;dump_on(st);}
  59 void StartNode::dump_compact_spec(outputStream *st) const { /* empty */ }
  60 #endif
  61 
  62 //------------------------------Ideal------------------------------------------
  63 Node *StartNode::Ideal(PhaseGVN *phase, bool can_reshape){
  64   return remove_dead_region(phase, can_reshape) ? this : NULL;
  65 }
  66 
  67 //------------------------------calling_convention-----------------------------
  68 void StartNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
  69   Matcher::calling_convention( sig_bt, parm_regs, argcnt, false );
  70 }
  71 
  72 //------------------------------Registers--------------------------------------
  73 const RegMask &amp;StartNode::in_RegMask(uint) const {
  74   return RegMask::Empty;
  75 }
  76 
  77 //------------------------------match------------------------------------------
  78 // Construct projections for incoming parameters, and their RegMask info
  79 Node *StartNode::match( const ProjNode *proj, const Matcher *match ) {
  80   switch (proj-&gt;_con) {
  81   case TypeFunc::Control:
  82   case TypeFunc::I_O:
  83   case TypeFunc::Memory:
  84     return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
  85   case TypeFunc::FramePtr:
  86     return new MachProjNode(this,proj-&gt;_con,Matcher::c_frame_ptr_mask, Op_RegP);
  87   case TypeFunc::ReturnAdr:
  88     return new MachProjNode(this,proj-&gt;_con,match-&gt;_return_addr_mask,Op_RegP);
  89   case TypeFunc::Parms:
  90   default: {
  91       uint parm_num = proj-&gt;_con - TypeFunc::Parms;
  92       const Type *t = _domain-&gt;field_at(proj-&gt;_con);
  93       if (t-&gt;base() == Type::Half)  // 2nd half of Longs and Doubles
  94         return new ConNode(Type::TOP);
  95       uint ideal_reg = t-&gt;ideal_reg();
  96       RegMask &amp;rm = match-&gt;_calling_convention_mask[parm_num];
  97       return new MachProjNode(this,proj-&gt;_con,rm,ideal_reg);
  98     }
  99   }
 100   return NULL;
 101 }
 102 
 103 //------------------------------StartOSRNode----------------------------------
 104 // The method start node for an on stack replacement adapter
 105 
 106 //------------------------------osr_domain-----------------------------
 107 const TypeTuple *StartOSRNode::osr_domain() {
 108   const Type **fields = TypeTuple::fields(2);
 109   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer
 110 
 111   return TypeTuple::make(TypeFunc::Parms+1, fields);
 112 }
 113 
 114 //=============================================================================
 115 const char * const ParmNode::names[TypeFunc::Parms+1] = {
 116   &quot;Control&quot;, &quot;I_O&quot;, &quot;Memory&quot;, &quot;FramePtr&quot;, &quot;ReturnAdr&quot;, &quot;Parms&quot;
 117 };
 118 
 119 #ifndef PRODUCT
 120 void ParmNode::dump_spec(outputStream *st) const {
 121   if( _con &lt; TypeFunc::Parms ) {
 122     st-&gt;print(&quot;%s&quot;, names[_con]);
 123   } else {
 124     st-&gt;print(&quot;Parm%d: &quot;,_con-TypeFunc::Parms);
 125     // Verbose and WizardMode dump bottom_type for all nodes
 126     if( !Verbose &amp;&amp; !WizardMode )   bottom_type()-&gt;dump_on(st);
 127   }
 128 }
 129 
 130 void ParmNode::dump_compact_spec(outputStream *st) const {
 131   if (_con &lt; TypeFunc::Parms) {
 132     st-&gt;print(&quot;%s&quot;, names[_con]);
 133   } else {
 134     st-&gt;print(&quot;%d:&quot;, _con-TypeFunc::Parms);
 135     // unconditionally dump bottom_type
 136     bottom_type()-&gt;dump_on(st);
 137   }
 138 }
 139 
 140 // For a ParmNode, all immediate inputs and outputs are considered relevant
 141 // both in compact and standard representation.
 142 void ParmNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
 143   this-&gt;collect_nodes(in_rel, 1, false, false);
 144   this-&gt;collect_nodes(out_rel, -1, false, false);
 145 }
 146 #endif
 147 
 148 uint ParmNode::ideal_reg() const {
 149   switch( _con ) {
 150   case TypeFunc::Control  : // fall through
 151   case TypeFunc::I_O      : // fall through
 152   case TypeFunc::Memory   : return 0;
 153   case TypeFunc::FramePtr : // fall through
 154   case TypeFunc::ReturnAdr: return Op_RegP;
 155   default                 : assert( _con &gt; TypeFunc::Parms, &quot;&quot; );
 156     // fall through
 157   case TypeFunc::Parms    : {
 158     // Type of argument being passed
 159     const Type *t = in(0)-&gt;as_Start()-&gt;_domain-&gt;field_at(_con);
 160     return t-&gt;ideal_reg();
 161   }
 162   }
 163   ShouldNotReachHere();
 164   return 0;
 165 }
 166 
 167 //=============================================================================
 168 ReturnNode::ReturnNode(uint edges, Node *cntrl, Node *i_o, Node *memory, Node *frameptr, Node *retadr ) : Node(edges) {
 169   init_req(TypeFunc::Control,cntrl);
 170   init_req(TypeFunc::I_O,i_o);
 171   init_req(TypeFunc::Memory,memory);
 172   init_req(TypeFunc::FramePtr,frameptr);
 173   init_req(TypeFunc::ReturnAdr,retadr);
 174 }
 175 
 176 Node *ReturnNode::Ideal(PhaseGVN *phase, bool can_reshape){
 177   return remove_dead_region(phase, can_reshape) ? this : NULL;
 178 }
 179 
 180 const Type* ReturnNode::Value(PhaseGVN* phase) const {
 181   return ( phase-&gt;type(in(TypeFunc::Control)) == Type::TOP)
 182     ? Type::TOP
 183     : Type::BOTTOM;
 184 }
 185 
 186 // Do we Match on this edge index or not?  No edges on return nodes
 187 uint ReturnNode::match_edge(uint idx) const {
 188   return 0;
 189 }
 190 
 191 
 192 #ifndef PRODUCT
 193 void ReturnNode::dump_req(outputStream *st) const {
 194   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 195   uint i;                       // Exit value of loop
 196   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 197     if (i == TypeFunc::Parms) st-&gt;print(&quot;returns&quot;);
 198     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 199     else st-&gt;print(&quot;_ &quot;);
 200   }
 201 }
 202 #endif
 203 
 204 //=============================================================================
 205 RethrowNode::RethrowNode(
 206   Node* cntrl,
 207   Node* i_o,
 208   Node* memory,
 209   Node* frameptr,
 210   Node* ret_adr,
 211   Node* exception
 212 ) : Node(TypeFunc::Parms + 1) {
 213   init_req(TypeFunc::Control  , cntrl    );
 214   init_req(TypeFunc::I_O      , i_o      );
 215   init_req(TypeFunc::Memory   , memory   );
 216   init_req(TypeFunc::FramePtr , frameptr );
 217   init_req(TypeFunc::ReturnAdr, ret_adr);
 218   init_req(TypeFunc::Parms    , exception);
 219 }
 220 
 221 Node *RethrowNode::Ideal(PhaseGVN *phase, bool can_reshape){
 222   return remove_dead_region(phase, can_reshape) ? this : NULL;
 223 }
 224 
 225 const Type* RethrowNode::Value(PhaseGVN* phase) const {
 226   return (phase-&gt;type(in(TypeFunc::Control)) == Type::TOP)
 227     ? Type::TOP
 228     : Type::BOTTOM;
 229 }
 230 
 231 uint RethrowNode::match_edge(uint idx) const {
 232   return 0;
 233 }
 234 
 235 #ifndef PRODUCT
 236 void RethrowNode::dump_req(outputStream *st) const {
 237   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 238   uint i;                       // Exit value of loop
 239   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 240     if (i == TypeFunc::Parms) st-&gt;print(&quot;exception&quot;);
 241     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 242     else st-&gt;print(&quot;_ &quot;);
 243   }
 244 }
 245 #endif
 246 
 247 //=============================================================================
 248 // Do we Match on this edge index or not?  Match only target address &amp; method
 249 uint TailCallNode::match_edge(uint idx) const {
 250   return TypeFunc::Parms &lt;= idx  &amp;&amp;  idx &lt;= TypeFunc::Parms+1;
 251 }
 252 
 253 //=============================================================================
 254 // Do we Match on this edge index or not?  Match only target address &amp; oop
 255 uint TailJumpNode::match_edge(uint idx) const {
 256   return TypeFunc::Parms &lt;= idx  &amp;&amp;  idx &lt;= TypeFunc::Parms+1;
 257 }
 258 
 259 //=============================================================================
 260 JVMState::JVMState(ciMethod* method, JVMState* caller) :
 261   _method(method) {
 262   assert(method != NULL, &quot;must be valid call site&quot;);
 263   _bci = InvocationEntryBci;
 264   _reexecute = Reexecute_Undefined;
 265   debug_only(_bci = -99);  // random garbage value
 266   debug_only(_map = (SafePointNode*)-1);
 267   _caller = caller;
 268   _depth  = 1 + (caller == NULL ? 0 : caller-&gt;depth());
 269   _locoff = TypeFunc::Parms;
 270   _stkoff = _locoff + _method-&gt;max_locals();
 271   _monoff = _stkoff + _method-&gt;max_stack();
 272   _scloff = _monoff;
 273   _endoff = _monoff;
 274   _sp = 0;
 275 }
 276 JVMState::JVMState(int stack_size) :
 277   _method(NULL) {
 278   _bci = InvocationEntryBci;
 279   _reexecute = Reexecute_Undefined;
 280   debug_only(_map = (SafePointNode*)-1);
 281   _caller = NULL;
 282   _depth  = 1;
 283   _locoff = TypeFunc::Parms;
 284   _stkoff = _locoff;
 285   _monoff = _stkoff + stack_size;
 286   _scloff = _monoff;
 287   _endoff = _monoff;
 288   _sp = 0;
 289 }
 290 
 291 //--------------------------------of_depth-------------------------------------
 292 JVMState* JVMState::of_depth(int d) const {
 293   const JVMState* jvmp = this;
 294   assert(0 &lt; d &amp;&amp; (uint)d &lt;= depth(), &quot;oob&quot;);
 295   for (int skip = depth() - d; skip &gt; 0; skip--) {
 296     jvmp = jvmp-&gt;caller();
 297   }
 298   assert(jvmp-&gt;depth() == (uint)d, &quot;found the right one&quot;);
 299   return (JVMState*)jvmp;
 300 }
 301 
 302 //-----------------------------same_calls_as-----------------------------------
 303 bool JVMState::same_calls_as(const JVMState* that) const {
 304   if (this == that)                    return true;
 305   if (this-&gt;depth() != that-&gt;depth())  return false;
 306   const JVMState* p = this;
 307   const JVMState* q = that;
 308   for (;;) {
 309     if (p-&gt;_method != q-&gt;_method)    return false;
 310     if (p-&gt;_method == NULL)          return true;   // bci is irrelevant
 311     if (p-&gt;_bci    != q-&gt;_bci)       return false;
 312     if (p-&gt;_reexecute != q-&gt;_reexecute)  return false;
 313     p = p-&gt;caller();
 314     q = q-&gt;caller();
 315     if (p == q)                      return true;
 316     assert(p != NULL &amp;&amp; q != NULL, &quot;depth check ensures we don&#39;t run off end&quot;);
 317   }
 318 }
 319 
 320 //------------------------------debug_start------------------------------------
 321 uint JVMState::debug_start()  const {
 322   debug_only(JVMState* jvmroot = of_depth(1));
 323   assert(jvmroot-&gt;locoff() &lt;= this-&gt;locoff(), &quot;youngest JVMState must be last&quot;);
 324   return of_depth(1)-&gt;locoff();
 325 }
 326 
 327 //-------------------------------debug_end-------------------------------------
 328 uint JVMState::debug_end() const {
 329   debug_only(JVMState* jvmroot = of_depth(1));
 330   assert(jvmroot-&gt;endoff() &lt;= this-&gt;endoff(), &quot;youngest JVMState must be last&quot;);
 331   return endoff();
 332 }
 333 
 334 //------------------------------debug_depth------------------------------------
 335 uint JVMState::debug_depth() const {
 336   uint total = 0;
 337   for (const JVMState* jvmp = this; jvmp != NULL; jvmp = jvmp-&gt;caller()) {
 338     total += jvmp-&gt;debug_size();
 339   }
 340   return total;
 341 }
 342 
 343 #ifndef PRODUCT
 344 
 345 //------------------------------format_helper----------------------------------
 346 // Given an allocation (a Chaitin object) and a Node decide if the Node carries
 347 // any defined value or not.  If it does, print out the register or constant.
 348 static void format_helper( PhaseRegAlloc *regalloc, outputStream* st, Node *n, const char *msg, uint i, GrowableArray&lt;SafePointScalarObjectNode*&gt; *scobjs ) {
 349   if (n == NULL) { st-&gt;print(&quot; NULL&quot;); return; }
 350   if (n-&gt;is_SafePointScalarObject()) {
 351     // Scalar replacement.
 352     SafePointScalarObjectNode* spobj = n-&gt;as_SafePointScalarObject();
 353     scobjs-&gt;append_if_missing(spobj);
 354     int sco_n = scobjs-&gt;find(spobj);
 355     assert(sco_n &gt;= 0, &quot;&quot;);
 356     st-&gt;print(&quot; %s%d]=#ScObj&quot; INT32_FORMAT, msg, i, sco_n);
 357     return;
 358   }
 359   if (regalloc-&gt;node_regs_max_index() &gt; 0 &amp;&amp;
 360       OptoReg::is_valid(regalloc-&gt;get_reg_first(n))) { // Check for undefined
 361     char buf[50];
 362     regalloc-&gt;dump_register(n,buf);
 363     st-&gt;print(&quot; %s%d]=%s&quot;,msg,i,buf);
 364   } else {                      // No register, but might be constant
 365     const Type *t = n-&gt;bottom_type();
 366     switch (t-&gt;base()) {
 367     case Type::Int:
 368       st-&gt;print(&quot; %s%d]=#&quot; INT32_FORMAT,msg,i,t-&gt;is_int()-&gt;get_con());
 369       break;
 370     case Type::AnyPtr:
 371       assert( t == TypePtr::NULL_PTR || n-&gt;in_dump(), &quot;&quot; );
 372       st-&gt;print(&quot; %s%d]=#NULL&quot;,msg,i);
 373       break;
 374     case Type::AryPtr:
 375     case Type::InstPtr:
 376       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;isa_oopptr()-&gt;const_oop()));
 377       break;
 378     case Type::KlassPtr:
 379       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;make_ptr()-&gt;isa_klassptr()-&gt;klass()));
 380       break;
 381     case Type::MetadataPtr:
 382       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;make_ptr()-&gt;isa_metadataptr()-&gt;metadata()));
 383       break;
 384     case Type::NarrowOop:
 385       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;make_ptr()-&gt;isa_oopptr()-&gt;const_oop()));
 386       break;
 387     case Type::RawPtr:
 388       st-&gt;print(&quot; %s%d]=#Raw&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;is_rawptr()));
 389       break;
 390     case Type::DoubleCon:
 391       st-&gt;print(&quot; %s%d]=#%fD&quot;,msg,i,t-&gt;is_double_constant()-&gt;_d);
 392       break;
 393     case Type::FloatCon:
 394       st-&gt;print(&quot; %s%d]=#%fF&quot;,msg,i,t-&gt;is_float_constant()-&gt;_f);
 395       break;
 396     case Type::Long:
 397       st-&gt;print(&quot; %s%d]=#&quot; INT64_FORMAT,msg,i,(int64_t)(t-&gt;is_long()-&gt;get_con()));
 398       break;
 399     case Type::Half:
 400     case Type::Top:
 401       st-&gt;print(&quot; %s%d]=_&quot;,msg,i);
 402       break;
 403     default: ShouldNotReachHere();
 404     }
 405   }
 406 }
 407 
 408 //------------------------------format-----------------------------------------
 409 void JVMState::format(PhaseRegAlloc *regalloc, const Node *n, outputStream* st) const {
 410   st-&gt;print(&quot;        #&quot;);
 411   if (_method) {
 412     _method-&gt;print_short_name(st);
 413     st-&gt;print(&quot; @ bci:%d &quot;,_bci);
 414   } else {
 415     st-&gt;print_cr(&quot; runtime stub &quot;);
 416     return;
 417   }
 418   if (n-&gt;is_MachSafePoint()) {
 419     GrowableArray&lt;SafePointScalarObjectNode*&gt; scobjs;
 420     MachSafePointNode *mcall = n-&gt;as_MachSafePoint();
 421     uint i;
 422     // Print locals
 423     for (i = 0; i &lt; (uint)loc_size(); i++)
 424       format_helper(regalloc, st, mcall-&gt;local(this, i), &quot;L[&quot;, i, &amp;scobjs);
 425     // Print stack
 426     for (i = 0; i &lt; (uint)stk_size(); i++) {
 427       if ((uint)(_stkoff + i) &gt;= mcall-&gt;len())
 428         st-&gt;print(&quot; oob &quot;);
 429       else
 430        format_helper(regalloc, st, mcall-&gt;stack(this, i), &quot;STK[&quot;, i, &amp;scobjs);
 431     }
 432     for (i = 0; (int)i &lt; nof_monitors(); i++) {
 433       Node *box = mcall-&gt;monitor_box(this, i);
 434       Node *obj = mcall-&gt;monitor_obj(this, i);
 435       if (regalloc-&gt;node_regs_max_index() &gt; 0 &amp;&amp;
 436           OptoReg::is_valid(regalloc-&gt;get_reg_first(box))) {
 437         box = BoxLockNode::box_node(box);
 438         format_helper(regalloc, st, box, &quot;MON-BOX[&quot;, i, &amp;scobjs);
 439       } else {
 440         OptoReg::Name box_reg = BoxLockNode::reg(box);
 441         st-&gt;print(&quot; MON-BOX%d=%s+%d&quot;,
 442                    i,
 443                    OptoReg::regname(OptoReg::c_frame_pointer),
 444                    regalloc-&gt;reg2offset(box_reg));
 445       }
 446       const char* obj_msg = &quot;MON-OBJ[&quot;;
 447       if (EliminateLocks) {
 448         if (BoxLockNode::box_node(box)-&gt;is_eliminated())
 449           obj_msg = &quot;MON-OBJ(LOCK ELIMINATED)[&quot;;
 450       }
 451       format_helper(regalloc, st, obj, obj_msg, i, &amp;scobjs);
 452     }
 453 
 454     for (i = 0; i &lt; (uint)scobjs.length(); i++) {
 455       // Scalar replaced objects.
 456       st-&gt;cr();
 457       st-&gt;print(&quot;        # ScObj&quot; INT32_FORMAT &quot; &quot;, i);
 458       SafePointScalarObjectNode* spobj = scobjs.at(i);
 459       ciKlass* cik = spobj-&gt;bottom_type()-&gt;is_oopptr()-&gt;klass();
 460       assert(cik-&gt;is_instance_klass() ||
 461              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 462       ciInstanceKlass *iklass = NULL;
 463       if (cik-&gt;is_instance_klass()) {
 464         cik-&gt;print_name_on(st);
 465         iklass = cik-&gt;as_instance_klass();
 466       } else if (cik-&gt;is_type_array_klass()) {
 467         cik-&gt;as_array_klass()-&gt;base_element_type()-&gt;print_name_on(st);
 468         st-&gt;print(&quot;[%d]&quot;, spobj-&gt;n_fields());
 469       } else if (cik-&gt;is_obj_array_klass()) {
 470         ciKlass* cie = cik-&gt;as_obj_array_klass()-&gt;base_element_klass();
 471         if (cie-&gt;is_instance_klass()) {
 472           cie-&gt;print_name_on(st);
 473         } else if (cie-&gt;is_type_array_klass()) {
 474           cie-&gt;as_array_klass()-&gt;base_element_type()-&gt;print_name_on(st);
 475         } else {
 476           ShouldNotReachHere();
 477         }
 478         st-&gt;print(&quot;[%d]&quot;, spobj-&gt;n_fields());
 479         int ndim = cik-&gt;as_array_klass()-&gt;dimension() - 1;
 480         while (ndim-- &gt; 0) {
 481           st-&gt;print(&quot;[]&quot;);
 482         }
 483       }
 484       st-&gt;print(&quot;={&quot;);
 485       uint nf = spobj-&gt;n_fields();
 486       if (nf &gt; 0) {
 487         uint first_ind = spobj-&gt;first_index(mcall-&gt;jvms());
<a name="1" id="anc1"></a><span class="line-modified"> 488         Node* fld_node = NULL;</span>
 489         ciField* cifield;
 490         if (iklass != NULL) {
 491           st-&gt;print(&quot; [&quot;);
 492           cifield = iklass-&gt;nonstatic_field_at(0);
 493           cifield-&gt;print_name_on(st);
<a name="2" id="anc2"></a><span class="line-modified"> 494           if(spobj-&gt;stack_allocated()) {</span>
<span class="line-added"> 495             st-&gt;print(&quot;:*0]&quot;);</span>
<span class="line-added"> 496           } else {</span>
<span class="line-added"> 497             fld_node = mcall-&gt;in(first_ind);</span>
<span class="line-added"> 498             format_helper(regalloc, st, fld_node, &quot;:&quot;, 0, &amp;scobjs);</span>
<span class="line-added"> 499           }</span>
 500         } else {
<a name="3" id="anc3"></a><span class="line-modified"> 501           if(spobj-&gt;stack_allocated()) {</span>
<span class="line-added"> 502             st-&gt;print(&quot;[*0]&quot;);</span>
<span class="line-added"> 503           } else {</span>
<span class="line-added"> 504             fld_node = mcall-&gt;in(first_ind);</span>
<span class="line-added"> 505             format_helper(regalloc, st, fld_node, &quot;[&quot;, 0, &amp;scobjs);</span>
<span class="line-added"> 506           }</span>
 507         }
 508         for (uint j = 1; j &lt; nf; j++) {
<a name="4" id="anc4"></a>
 509           if (iklass != NULL) {
 510             st-&gt;print(&quot;, [&quot;);
 511             cifield = iklass-&gt;nonstatic_field_at(j);
 512             cifield-&gt;print_name_on(st);
<a name="5" id="anc5"></a><span class="line-modified"> 513             if(spobj-&gt;stack_allocated()) {</span>
<span class="line-added"> 514               st-&gt;print(&quot;:*%d]&quot;, j);</span>
<span class="line-added"> 515             } else {</span>
<span class="line-added"> 516               fld_node = mcall-&gt;in(first_ind+j);</span>
<span class="line-added"> 517               format_helper(regalloc, st, fld_node, &quot;:&quot;, j, &amp;scobjs);</span>
<span class="line-added"> 518             }</span>
 519           } else {
<a name="6" id="anc6"></a><span class="line-modified"> 520             if(spobj-&gt;stack_allocated()) {</span>
<span class="line-added"> 521               st-&gt;print(&quot;, [*%d]&quot;, j);</span>
<span class="line-added"> 522             } else {</span>
<span class="line-added"> 523               fld_node = mcall-&gt;in(first_ind+j);</span>
<span class="line-added"> 524               format_helper(regalloc, st, fld_node, &quot;, [&quot;, j, &amp;scobjs);</span>
<span class="line-added"> 525             }</span>
 526           }
 527         }
 528       }
 529       st-&gt;print(&quot; }&quot;);
 530     }
 531   }
 532   st-&gt;cr();
 533   if (caller() != NULL) caller()-&gt;format(regalloc, n, st);
 534 }
 535 
 536 
 537 void JVMState::dump_spec(outputStream *st) const {
 538   if (_method != NULL) {
 539     bool printed = false;
 540     if (!Verbose) {
 541       // The JVMS dumps make really, really long lines.
 542       // Take out the most boring parts, which are the package prefixes.
 543       char buf[500];
 544       stringStream namest(buf, sizeof(buf));
 545       _method-&gt;print_short_name(&amp;namest);
 546       if (namest.count() &lt; sizeof(buf)) {
 547         const char* name = namest.base();
 548         if (name[0] == &#39; &#39;)  ++name;
 549         const char* endcn = strchr(name, &#39;:&#39;);  // end of class name
 550         if (endcn == NULL)  endcn = strchr(name, &#39;(&#39;);
 551         if (endcn == NULL)  endcn = name + strlen(name);
 552         while (endcn &gt; name &amp;&amp; endcn[-1] != &#39;.&#39; &amp;&amp; endcn[-1] != &#39;/&#39;)
 553           --endcn;
 554         st-&gt;print(&quot; %s&quot;, endcn);
 555         printed = true;
 556       }
 557     }
 558     if (!printed)
 559       _method-&gt;print_short_name(st);
 560     st-&gt;print(&quot; @ bci:%d&quot;,_bci);
 561     if(_reexecute == Reexecute_True)
 562       st-&gt;print(&quot; reexecute&quot;);
 563   } else {
 564     st-&gt;print(&quot; runtime stub&quot;);
 565   }
 566   if (caller() != NULL)  caller()-&gt;dump_spec(st);
 567 }
 568 
 569 
 570 void JVMState::dump_on(outputStream* st) const {
 571   bool print_map = _map &amp;&amp; !((uintptr_t)_map &amp; 1) &amp;&amp;
 572                   ((caller() == NULL) || (caller()-&gt;map() != _map));
 573   if (print_map) {
 574     if (_map-&gt;len() &gt; _map-&gt;req()) {  // _map-&gt;has_exceptions()
 575       Node* ex = _map-&gt;in(_map-&gt;req());  // _map-&gt;next_exception()
 576       // skip the first one; it&#39;s already being printed
 577       while (ex != NULL &amp;&amp; ex-&gt;len() &gt; ex-&gt;req()) {
 578         ex = ex-&gt;in(ex-&gt;req());  // ex-&gt;next_exception()
 579         ex-&gt;dump(1);
 580       }
 581     }
 582     _map-&gt;dump(Verbose ? 2 : 1);
 583   }
 584   if (caller() != NULL) {
 585     caller()-&gt;dump_on(st);
 586   }
 587   st-&gt;print(&quot;JVMS depth=%d loc=%d stk=%d arg=%d mon=%d scalar=%d end=%d mondepth=%d sp=%d bci=%d reexecute=%s method=&quot;,
 588              depth(), locoff(), stkoff(), argoff(), monoff(), scloff(), endoff(), monitor_depth(), sp(), bci(), should_reexecute()?&quot;true&quot;:&quot;false&quot;);
 589   if (_method == NULL) {
 590     st-&gt;print_cr(&quot;(none)&quot;);
 591   } else {
 592     _method-&gt;print_name(st);
 593     st-&gt;cr();
 594     if (bci() &gt;= 0 &amp;&amp; bci() &lt; _method-&gt;code_size()) {
 595       st-&gt;print(&quot;    bc: &quot;);
 596       _method-&gt;print_codes_on(bci(), bci()+1, st);
 597     }
 598   }
 599 }
 600 
 601 // Extra way to dump a jvms from the debugger,
 602 // to avoid a bug with C++ member function calls.
 603 void dump_jvms(JVMState* jvms) {
 604   jvms-&gt;dump();
 605 }
 606 #endif
 607 
 608 //--------------------------clone_shallow--------------------------------------
 609 JVMState* JVMState::clone_shallow(Compile* C) const {
 610   JVMState* n = has_method() ? new (C) JVMState(_method, _caller) : new (C) JVMState(0);
 611   n-&gt;set_bci(_bci);
 612   n-&gt;_reexecute = _reexecute;
 613   n-&gt;set_locoff(_locoff);
 614   n-&gt;set_stkoff(_stkoff);
 615   n-&gt;set_monoff(_monoff);
 616   n-&gt;set_scloff(_scloff);
 617   n-&gt;set_endoff(_endoff);
 618   n-&gt;set_sp(_sp);
 619   n-&gt;set_map(_map);
 620   return n;
 621 }
 622 
 623 //---------------------------clone_deep----------------------------------------
 624 JVMState* JVMState::clone_deep(Compile* C) const {
 625   JVMState* n = clone_shallow(C);
 626   for (JVMState* p = n; p-&gt;_caller != NULL; p = p-&gt;_caller) {
 627     p-&gt;_caller = p-&gt;_caller-&gt;clone_shallow(C);
 628   }
 629   assert(n-&gt;depth() == depth(), &quot;sanity&quot;);
 630   assert(n-&gt;debug_depth() == debug_depth(), &quot;sanity&quot;);
 631   return n;
 632 }
 633 
 634 /**
 635  * Reset map for all callers
 636  */
 637 void JVMState::set_map_deep(SafePointNode* map) {
 638   for (JVMState* p = this; p-&gt;_caller != NULL; p = p-&gt;_caller) {
 639     p-&gt;set_map(map);
 640   }
 641 }
 642 
 643 // Adapt offsets in in-array after adding or removing an edge.
 644 // Prerequisite is that the JVMState is used by only one node.
 645 void JVMState::adapt_position(int delta) {
 646   for (JVMState* jvms = this; jvms != NULL; jvms = jvms-&gt;caller()) {
 647     jvms-&gt;set_locoff(jvms-&gt;locoff() + delta);
 648     jvms-&gt;set_stkoff(jvms-&gt;stkoff() + delta);
 649     jvms-&gt;set_monoff(jvms-&gt;monoff() + delta);
 650     jvms-&gt;set_scloff(jvms-&gt;scloff() + delta);
 651     jvms-&gt;set_endoff(jvms-&gt;endoff() + delta);
 652   }
 653 }
 654 
 655 // Mirror the stack size calculation in the deopt code
 656 // How much stack space would we need at this point in the program in
 657 // case of deoptimization?
 658 int JVMState::interpreter_frame_size() const {
 659   const JVMState* jvms = this;
 660   int size = 0;
 661   int callee_parameters = 0;
 662   int callee_locals = 0;
 663   int extra_args = method()-&gt;max_stack() - stk_size();
 664 
 665   while (jvms != NULL) {
 666     int locks = jvms-&gt;nof_monitors();
 667     int temps = jvms-&gt;stk_size();
 668     bool is_top_frame = (jvms == this);
 669     ciMethod* method = jvms-&gt;method();
 670 
 671     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
 672                                                                  temps + callee_parameters,
 673                                                                  extra_args,
 674                                                                  locks,
 675                                                                  callee_parameters,
 676                                                                  callee_locals,
 677                                                                  is_top_frame);
 678     size += frame_size;
 679 
 680     callee_parameters = method-&gt;size_of_parameters();
 681     callee_locals = method-&gt;max_locals();
 682     extra_args = 0;
 683     jvms = jvms-&gt;caller();
 684   }
 685   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
 686 }
 687 
 688 //=============================================================================
 689 bool CallNode::cmp( const Node &amp;n ) const
 690 { return _tf == ((CallNode&amp;)n)._tf &amp;&amp; _jvms == ((CallNode&amp;)n)._jvms; }
 691 #ifndef PRODUCT
 692 void CallNode::dump_req(outputStream *st) const {
 693   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 694   uint i;                       // Exit value of loop
 695   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 696     if (i == TypeFunc::Parms) st-&gt;print(&quot;(&quot;);
 697     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 698     else st-&gt;print(&quot;_ &quot;);
 699   }
 700   st-&gt;print(&quot;)&quot;);
 701 }
 702 
 703 void CallNode::dump_spec(outputStream *st) const {
 704   st-&gt;print(&quot; &quot;);
 705   if (tf() != NULL)  tf()-&gt;dump_on(st);
 706   if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
 707   if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
 708 }
 709 #endif
 710 
 711 const Type *CallNode::bottom_type() const { return tf()-&gt;range(); }
 712 const Type* CallNode::Value(PhaseGVN* phase) const {
 713   if (phase-&gt;type(in(0)) == Type::TOP)  return Type::TOP;
 714   return tf()-&gt;range();
 715 }
 716 
 717 //------------------------------calling_convention-----------------------------
 718 void CallNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
 719   // Use the standard compiler calling convention
 720   Matcher::calling_convention( sig_bt, parm_regs, argcnt, true );
 721 }
 722 
 723 
 724 //------------------------------match------------------------------------------
 725 // Construct projections for control, I/O, memory-fields, ..., and
 726 // return result(s) along with their RegMask info
 727 Node *CallNode::match( const ProjNode *proj, const Matcher *match ) {
 728   switch (proj-&gt;_con) {
 729   case TypeFunc::Control:
 730   case TypeFunc::I_O:
 731   case TypeFunc::Memory:
 732     return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
 733 
 734   case TypeFunc::Parms+1:       // For LONG &amp; DOUBLE returns
 735     assert(tf()-&gt;range()-&gt;field_at(TypeFunc::Parms+1) == Type::HALF, &quot;&quot;);
 736     // 2nd half of doubles and longs
 737     return new MachProjNode(this,proj-&gt;_con, RegMask::Empty, (uint)OptoReg::Bad);
 738 
 739   case TypeFunc::Parms: {       // Normal returns
 740     uint ideal_reg = tf()-&gt;range()-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();
 741     OptoRegPair regs = is_CallRuntime()
 742       ? match-&gt;c_return_value(ideal_reg,true)  // Calls into C runtime
 743       : match-&gt;  return_value(ideal_reg,true); // Calls into compiled Java code
 744     RegMask rm = RegMask(regs.first());
 745     if( OptoReg::is_valid(regs.second()) )
 746       rm.Insert( regs.second() );
 747     return new MachProjNode(this,proj-&gt;_con,rm,ideal_reg);
 748   }
 749 
 750   case TypeFunc::ReturnAdr:
 751   case TypeFunc::FramePtr:
 752   default:
 753     ShouldNotReachHere();
 754   }
 755   return NULL;
 756 }
 757 
 758 // Do we Match on this edge index or not?  Match no edges
 759 uint CallNode::match_edge(uint idx) const {
 760   return 0;
 761 }
 762 
 763 //
 764 // Determine whether the call could modify the field of the specified
 765 // instance at the specified offset.
 766 //
 767 bool CallNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {
 768   assert((t_oop != NULL), &quot;sanity&quot;);
 769   if (is_call_to_arraycopystub() &amp;&amp; strcmp(_name, &quot;unsafe_arraycopy&quot;) != 0) {
 770     const TypeTuple* args = _tf-&gt;domain();
 771     Node* dest = NULL;
 772     // Stubs that can be called once an ArrayCopyNode is expanded have
 773     // different signatures. Look for the second pointer argument,
 774     // that is the destination of the copy.
 775     for (uint i = TypeFunc::Parms, j = 0; i &lt; args-&gt;cnt(); i++) {
 776       if (args-&gt;field_at(i)-&gt;isa_ptr()) {
 777         j++;
 778         if (j == 2) {
 779           dest = in(i);
 780           break;
 781         }
 782       }
 783     }
 784     guarantee(dest != NULL, &quot;Call had only one ptr in, broken IR!&quot;);
 785     if (!dest-&gt;is_top() &amp;&amp; may_modify_arraycopy_helper(phase-&gt;type(dest)-&gt;is_oopptr(), t_oop, phase)) {
 786       return true;
 787     }
 788     return false;
 789   }
 790   if (t_oop-&gt;is_known_instance()) {
 791     // The instance_id is set only for scalar-replaceable allocations which
 792     // are not passed as arguments according to Escape Analysis.
 793     return false;
 794   }
 795   if (t_oop-&gt;is_ptr_to_boxed_value()) {
 796     ciKlass* boxing_klass = t_oop-&gt;klass();
 797     if (is_CallStaticJava() &amp;&amp; as_CallStaticJava()-&gt;is_boxing_method()) {
 798       // Skip unrelated boxing methods.
 799       Node* proj = proj_out_or_null(TypeFunc::Parms);
 800       if ((proj == NULL) || (phase-&gt;type(proj)-&gt;is_instptr()-&gt;klass() != boxing_klass)) {
 801         return false;
 802       }
 803     }
 804     if (is_CallJava() &amp;&amp; as_CallJava()-&gt;method() != NULL) {
 805       ciMethod* meth = as_CallJava()-&gt;method();
 806       if (meth-&gt;is_getter()) {
 807         return false;
 808       }
 809       // May modify (by reflection) if an boxing object is passed
 810       // as argument or returned.
 811       Node* proj = returns_pointer() ? proj_out_or_null(TypeFunc::Parms) : NULL;
 812       if (proj != NULL) {
 813         const TypeInstPtr* inst_t = phase-&gt;type(proj)-&gt;isa_instptr();
 814         if ((inst_t != NULL) &amp;&amp; (!inst_t-&gt;klass_is_exact() ||
 815                                  (inst_t-&gt;klass() == boxing_klass))) {
 816           return true;
 817         }
 818       }
 819       const TypeTuple* d = tf()-&gt;domain();
 820       for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
 821         const TypeInstPtr* inst_t = d-&gt;field_at(i)-&gt;isa_instptr();
 822         if ((inst_t != NULL) &amp;&amp; (!inst_t-&gt;klass_is_exact() ||
 823                                  (inst_t-&gt;klass() == boxing_klass))) {
 824           return true;
 825         }
 826       }
 827       return false;
 828     }
 829   }
 830   return true;
 831 }
 832 
 833 // Does this call have a direct reference to n other than debug information?
 834 bool CallNode::has_non_debug_use(Node *n) {
 835   const TypeTuple * d = tf()-&gt;domain();
 836   for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
 837     Node *arg = in(i);
 838     if (arg == n) {
 839       return true;
 840     }
 841   }
 842   return false;
 843 }
 844 
 845 // Returns the unique CheckCastPP of a call
 846 // or &#39;this&#39; if there are several CheckCastPP or unexpected uses
 847 // or returns NULL if there is no one.
 848 Node *CallNode::result_cast() {
 849   Node *cast = NULL;
 850 
 851   Node *p = proj_out_or_null(TypeFunc::Parms);
 852   if (p == NULL)
 853     return NULL;
 854 
 855   for (DUIterator_Fast imax, i = p-&gt;fast_outs(imax); i &lt; imax; i++) {
 856     Node *use = p-&gt;fast_out(i);
 857     if (use-&gt;is_CheckCastPP()) {
 858       if (cast != NULL) {
 859         return this;  // more than 1 CheckCastPP
 860       }
 861       cast = use;
 862     } else if (!use-&gt;is_Initialize() &amp;&amp;
 863                !use-&gt;is_AddP() &amp;&amp;
 864                use-&gt;Opcode() != Op_MemBarStoreStore) {
 865       // Expected uses are restricted to a CheckCastPP, an Initialize
 866       // node, a MemBarStoreStore (clone) and AddP nodes. If we
 867       // encounter any other use (a Phi node can be seen in rare
 868       // cases) return this to prevent incorrect optimizations.
 869       return this;
 870     }
 871   }
 872   return cast;
 873 }
 874 
 875 
 876 void CallNode::extract_projections(CallProjections* projs, bool separate_io_proj, bool do_asserts) {
 877   projs-&gt;fallthrough_proj      = NULL;
 878   projs-&gt;fallthrough_catchproj = NULL;
 879   projs-&gt;fallthrough_ioproj    = NULL;
 880   projs-&gt;catchall_ioproj       = NULL;
 881   projs-&gt;catchall_catchproj    = NULL;
 882   projs-&gt;fallthrough_memproj   = NULL;
 883   projs-&gt;catchall_memproj      = NULL;
 884   projs-&gt;resproj               = NULL;
 885   projs-&gt;exobj                 = NULL;
 886 
 887   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 888     ProjNode *pn = fast_out(i)-&gt;as_Proj();
 889     if (pn-&gt;outcnt() == 0) continue;
 890     switch (pn-&gt;_con) {
 891     case TypeFunc::Control:
 892       {
 893         // For Control (fallthrough) and I_O (catch_all_index) we have CatchProj -&gt; Catch -&gt; Proj
 894         projs-&gt;fallthrough_proj = pn;
 895         DUIterator_Fast jmax, j = pn-&gt;fast_outs(jmax);
 896         const Node *cn = pn-&gt;fast_out(j);
 897         if (cn-&gt;is_Catch()) {
 898           ProjNode *cpn = NULL;
 899           for (DUIterator_Fast kmax, k = cn-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 900             cpn = cn-&gt;fast_out(k)-&gt;as_Proj();
 901             assert(cpn-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
 902             if (cpn-&gt;_con == CatchProjNode::fall_through_index)
 903               projs-&gt;fallthrough_catchproj = cpn;
 904             else {
 905               assert(cpn-&gt;_con == CatchProjNode::catch_all_index, &quot;must be correct index.&quot;);
 906               projs-&gt;catchall_catchproj = cpn;
 907             }
 908           }
 909         }
 910         break;
 911       }
 912     case TypeFunc::I_O:
 913       if (pn-&gt;_is_io_use)
 914         projs-&gt;catchall_ioproj = pn;
 915       else
 916         projs-&gt;fallthrough_ioproj = pn;
 917       for (DUIterator j = pn-&gt;outs(); pn-&gt;has_out(j); j++) {
 918         Node* e = pn-&gt;out(j);
 919         if (e-&gt;Opcode() == Op_CreateEx &amp;&amp; e-&gt;in(0)-&gt;is_CatchProj() &amp;&amp; e-&gt;outcnt() &gt; 0) {
 920           assert(projs-&gt;exobj == NULL, &quot;only one&quot;);
 921           projs-&gt;exobj = e;
 922         }
 923       }
 924       break;
 925     case TypeFunc::Memory:
 926       if (pn-&gt;_is_io_use)
 927         projs-&gt;catchall_memproj = pn;
 928       else
 929         projs-&gt;fallthrough_memproj = pn;
 930       break;
 931     case TypeFunc::Parms:
 932       projs-&gt;resproj = pn;
 933       break;
 934     default:
 935       assert(false, &quot;unexpected projection from allocation node.&quot;);
 936     }
 937   }
 938 
 939   // The resproj may not exist because the result could be ignored
 940   // and the exception object may not exist if an exception handler
 941   // swallows the exception but all the other must exist and be found.
 942   assert(projs-&gt;fallthrough_proj      != NULL, &quot;must be found&quot;);
 943   do_asserts = do_asserts &amp;&amp; !Compile::current()-&gt;inlining_incrementally();
 944   assert(!do_asserts || projs-&gt;fallthrough_catchproj != NULL, &quot;must be found&quot;);
 945   assert(!do_asserts || projs-&gt;fallthrough_memproj   != NULL, &quot;must be found&quot;);
 946   assert(!do_asserts || projs-&gt;fallthrough_ioproj    != NULL, &quot;must be found&quot;);
 947   assert(!do_asserts || projs-&gt;catchall_catchproj    != NULL, &quot;must be found&quot;);
 948   if (separate_io_proj) {
 949     assert(!do_asserts || projs-&gt;catchall_memproj    != NULL, &quot;must be found&quot;);
 950     assert(!do_asserts || projs-&gt;catchall_ioproj     != NULL, &quot;must be found&quot;);
 951   }
 952 }
 953 
 954 Node *CallNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 955   CallGenerator* cg = generator();
 956   if (can_reshape &amp;&amp; cg != NULL &amp;&amp; cg-&gt;is_mh_late_inline() &amp;&amp; !cg-&gt;already_attempted()) {
 957     // Check whether this MH handle call becomes a candidate for inlining
 958     ciMethod* callee = cg-&gt;method();
 959     vmIntrinsics::ID iid = callee-&gt;intrinsic_id();
 960     if (iid == vmIntrinsics::_invokeBasic) {
 961       if (in(TypeFunc::Parms)-&gt;Opcode() == Op_ConP) {
 962         phase-&gt;C-&gt;prepend_late_inline(cg);
 963         set_generator(NULL);
 964       }
 965     } else {
 966       assert(callee-&gt;has_member_arg(), &quot;wrong type of call?&quot;);
 967       if (in(TypeFunc::Parms + callee-&gt;arg_size() - 1)-&gt;Opcode() == Op_ConP) {
 968         phase-&gt;C-&gt;prepend_late_inline(cg);
 969         set_generator(NULL);
 970       }
 971     }
 972   }
 973   return SafePointNode::Ideal(phase, can_reshape);
 974 }
 975 
 976 bool CallNode::is_call_to_arraycopystub() const {
 977   if (_name != NULL &amp;&amp; strstr(_name, &quot;arraycopy&quot;) != 0) {
 978     return true;
 979   }
 980   return false;
 981 }
 982 
<a name="7" id="anc7"></a><span class="line-added"> 983 bool CallNode::is_call_to_osr_migration_end() const {</span>
<span class="line-added"> 984   if (_name != NULL &amp;&amp; strstr(_name, &quot;OSR_migration_end&quot;) != 0) {</span>
<span class="line-added"> 985     return true;</span>
<span class="line-added"> 986   }</span>
<span class="line-added"> 987   return false;</span>
<span class="line-added"> 988 }</span>
<span class="line-added"> 989 </span>
 990 //=============================================================================
 991 uint CallJavaNode::size_of() const { return sizeof(*this); }
 992 bool CallJavaNode::cmp( const Node &amp;n ) const {
 993   CallJavaNode &amp;call = (CallJavaNode&amp;)n;
 994   return CallNode::cmp(call) &amp;&amp; _method == call._method &amp;&amp;
 995          _override_symbolic_info == call._override_symbolic_info;
 996 }
 997 #ifdef ASSERT
 998 bool CallJavaNode::validate_symbolic_info() const {
 999   if (method() == NULL) {
1000     return true; // call into runtime or uncommon trap
1001   }
1002   ciMethod* symbolic_info = jvms()-&gt;method()-&gt;get_method_at_bci(_bci);
1003   ciMethod* callee = method();
1004   if (symbolic_info-&gt;is_method_handle_intrinsic() &amp;&amp; !callee-&gt;is_method_handle_intrinsic()) {
1005     assert(override_symbolic_info(), &quot;should be set&quot;);
1006   }
1007   assert(ciMethod::is_consistent_info(symbolic_info, callee), &quot;inconsistent info&quot;);
1008   return true;
1009 }
1010 #endif
1011 
1012 #ifndef PRODUCT
1013 void CallJavaNode::dump_spec(outputStream *st) const {
1014   if( _method ) _method-&gt;print_short_name(st);
1015   CallNode::dump_spec(st);
1016 }
1017 
1018 void CallJavaNode::dump_compact_spec(outputStream* st) const {
1019   if (_method) {
1020     _method-&gt;print_short_name(st);
1021   } else {
1022     st-&gt;print(&quot;&lt;?&gt;&quot;);
1023   }
1024 }
1025 #endif
1026 
1027 //=============================================================================
1028 uint CallStaticJavaNode::size_of() const { return sizeof(*this); }
1029 bool CallStaticJavaNode::cmp( const Node &amp;n ) const {
1030   CallStaticJavaNode &amp;call = (CallStaticJavaNode&amp;)n;
1031   return CallJavaNode::cmp(call);
1032 }
1033 
1034 //----------------------------uncommon_trap_request----------------------------
1035 // If this is an uncommon trap, return the request code, else zero.
1036 int CallStaticJavaNode::uncommon_trap_request() const {
1037   if (_name != NULL &amp;&amp; !strcmp(_name, &quot;uncommon_trap&quot;)) {
1038     return extract_uncommon_trap_request(this);
1039   }
1040   return 0;
1041 }
1042 int CallStaticJavaNode::extract_uncommon_trap_request(const Node* call) {
1043 #ifndef PRODUCT
1044   if (!(call-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
1045         call-&gt;in(TypeFunc::Parms) != NULL &amp;&amp;
1046         call-&gt;in(TypeFunc::Parms)-&gt;is_Con() &amp;&amp;
1047         call-&gt;in(TypeFunc::Parms)-&gt;bottom_type()-&gt;isa_int())) {
1048     assert(in_dump() != 0, &quot;OK if dumping&quot;);
1049     tty-&gt;print(&quot;[bad uncommon trap]&quot;);
1050     return 0;
1051   }
1052 #endif
1053   return call-&gt;in(TypeFunc::Parms)-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
1054 }
1055 
1056 #ifndef PRODUCT
1057 void CallStaticJavaNode::dump_spec(outputStream *st) const {
1058   st-&gt;print(&quot;# Static &quot;);
1059   if (_name != NULL) {
1060     st-&gt;print(&quot;%s&quot;, _name);
1061     int trap_req = uncommon_trap_request();
1062     if (trap_req != 0) {
1063       char buf[100];
1064       st-&gt;print(&quot;(%s)&quot;,
1065                  Deoptimization::format_trap_request(buf, sizeof(buf),
1066                                                      trap_req));
1067     }
1068     st-&gt;print(&quot; &quot;);
1069   }
1070   CallJavaNode::dump_spec(st);
1071 }
1072 
1073 void CallStaticJavaNode::dump_compact_spec(outputStream* st) const {
1074   if (_method) {
1075     _method-&gt;print_short_name(st);
1076   } else if (_name) {
1077     st-&gt;print(&quot;%s&quot;, _name);
1078   } else {
1079     st-&gt;print(&quot;&lt;?&gt;&quot;);
1080   }
1081 }
1082 #endif
1083 
1084 //=============================================================================
1085 uint CallDynamicJavaNode::size_of() const { return sizeof(*this); }
1086 bool CallDynamicJavaNode::cmp( const Node &amp;n ) const {
1087   CallDynamicJavaNode &amp;call = (CallDynamicJavaNode&amp;)n;
1088   return CallJavaNode::cmp(call);
1089 }
1090 #ifndef PRODUCT
1091 void CallDynamicJavaNode::dump_spec(outputStream *st) const {
1092   st-&gt;print(&quot;# Dynamic &quot;);
1093   CallJavaNode::dump_spec(st);
1094 }
1095 #endif
1096 
1097 //=============================================================================
1098 uint CallRuntimeNode::size_of() const { return sizeof(*this); }
1099 bool CallRuntimeNode::cmp( const Node &amp;n ) const {
1100   CallRuntimeNode &amp;call = (CallRuntimeNode&amp;)n;
1101   return CallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
1102 }
1103 #ifndef PRODUCT
1104 void CallRuntimeNode::dump_spec(outputStream *st) const {
1105   st-&gt;print(&quot;# &quot;);
1106   st-&gt;print(&quot;%s&quot;, _name);
1107   CallNode::dump_spec(st);
1108 }
1109 #endif
1110 
1111 //------------------------------calling_convention-----------------------------
1112 void CallRuntimeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
1113   Matcher::c_calling_convention( sig_bt, parm_regs, argcnt );
1114 }
1115 
1116 //=============================================================================
1117 //------------------------------calling_convention-----------------------------
1118 
1119 
1120 //=============================================================================
1121 #ifndef PRODUCT
1122 void CallLeafNode::dump_spec(outputStream *st) const {
1123   st-&gt;print(&quot;# &quot;);
1124   st-&gt;print(&quot;%s&quot;, _name);
1125   CallNode::dump_spec(st);
1126 }
1127 #endif
1128 
1129 //=============================================================================
1130 
1131 void SafePointNode::set_local(JVMState* jvms, uint idx, Node *c) {
1132   assert(verify_jvms(jvms), &quot;jvms must match&quot;);
1133   int loc = jvms-&gt;locoff() + idx;
1134   if (in(loc)-&gt;is_top() &amp;&amp; idx &gt; 0 &amp;&amp; !c-&gt;is_top() ) {
1135     // If current local idx is top then local idx - 1 could
1136     // be a long/double that needs to be killed since top could
1137     // represent the 2nd half ofthe long/double.
1138     uint ideal = in(loc -1)-&gt;ideal_reg();
1139     if (ideal == Op_RegD || ideal == Op_RegL) {
1140       // set other (low index) half to top
1141       set_req(loc - 1, in(loc));
1142     }
1143   }
1144   set_req(loc, c);
1145 }
1146 
1147 uint SafePointNode::size_of() const { return sizeof(*this); }
1148 bool SafePointNode::cmp( const Node &amp;n ) const {
1149   return (&amp;n == this);          // Always fail except on self
1150 }
1151 
1152 //-------------------------set_next_exception----------------------------------
1153 void SafePointNode::set_next_exception(SafePointNode* n) {
1154   assert(n == NULL || n-&gt;Opcode() == Op_SafePoint, &quot;correct value for next_exception&quot;);
1155   if (len() == req()) {
1156     if (n != NULL)  add_prec(n);
1157   } else {
1158     set_prec(req(), n);
1159   }
1160 }
1161 
1162 
1163 //----------------------------next_exception-----------------------------------
1164 SafePointNode* SafePointNode::next_exception() const {
1165   if (len() == req()) {
1166     return NULL;
1167   } else {
1168     Node* n = in(req());
1169     assert(n == NULL || n-&gt;Opcode() == Op_SafePoint, &quot;no other uses of prec edges&quot;);
1170     return (SafePointNode*) n;
1171   }
1172 }
1173 
1174 
1175 //------------------------------Ideal------------------------------------------
1176 // Skip over any collapsed Regions
1177 Node *SafePointNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1178   return remove_dead_region(phase, can_reshape) ? this : NULL;
1179 }
1180 
1181 //------------------------------Identity---------------------------------------
1182 // Remove obviously duplicate safepoints
1183 Node* SafePointNode::Identity(PhaseGVN* phase) {
1184 
1185   // If you have back to back safepoints, remove one
1186   if( in(TypeFunc::Control)-&gt;is_SafePoint() )
1187     return in(TypeFunc::Control);
1188 
1189   if( in(0)-&gt;is_Proj() ) {
1190     Node *n0 = in(0)-&gt;in(0);
1191     // Check if he is a call projection (except Leaf Call)
1192     if( n0-&gt;is_Catch() ) {
1193       n0 = n0-&gt;in(0)-&gt;in(0);
1194       assert( n0-&gt;is_Call(), &quot;expect a call here&quot; );
1195     }
1196     if( n0-&gt;is_Call() &amp;&amp; n0-&gt;as_Call()-&gt;guaranteed_safepoint() ) {
1197       // Don&#39;t remove a safepoint belonging to an OuterStripMinedLoopEndNode.
1198       // If the loop dies, they will be removed together.
1199       if (has_out_with(Op_OuterStripMinedLoopEnd)) {
1200         return this;
1201       }
1202       // Useless Safepoint, so remove it
1203       return in(TypeFunc::Control);
1204     }
1205   }
1206 
1207   return this;
1208 }
1209 
1210 //------------------------------Value------------------------------------------
1211 const Type* SafePointNode::Value(PhaseGVN* phase) const {
1212   if( phase-&gt;type(in(0)) == Type::TOP ) return Type::TOP;
1213   if( phase-&gt;eqv( in(0), this ) ) return Type::TOP; // Dead infinite loop
1214   return Type::CONTROL;
1215 }
1216 
1217 #ifndef PRODUCT
1218 void SafePointNode::dump_spec(outputStream *st) const {
1219   st-&gt;print(&quot; SafePoint &quot;);
1220   _replaced_nodes.dump(st);
1221 }
1222 
1223 // The related nodes of a SafepointNode are all data inputs, excluding the
1224 // control boundary, as well as all outputs till level 2 (to include projection
1225 // nodes and targets). In compact mode, just include inputs till level 1 and
1226 // outputs as before.
1227 void SafePointNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1228   if (compact) {
1229     this-&gt;collect_nodes(in_rel, 1, false, false);
1230   } else {
1231     this-&gt;collect_nodes_in_all_data(in_rel, false);
1232   }
1233   this-&gt;collect_nodes(out_rel, -2, false, false);
1234 }
1235 #endif
1236 
1237 const RegMask &amp;SafePointNode::in_RegMask(uint idx) const {
1238   if( idx &lt; TypeFunc::Parms ) return RegMask::Empty;
1239   // Values outside the domain represent debug info
1240   return *(Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()]);
1241 }
1242 const RegMask &amp;SafePointNode::out_RegMask() const {
1243   return RegMask::Empty;
1244 }
1245 
1246 
1247 void SafePointNode::grow_stack(JVMState* jvms, uint grow_by) {
1248   assert((int)grow_by &gt; 0, &quot;sanity&quot;);
1249   int monoff = jvms-&gt;monoff();
1250   int scloff = jvms-&gt;scloff();
1251   int endoff = jvms-&gt;endoff();
1252   assert(endoff == (int)req(), &quot;no other states or debug info after me&quot;);
1253   Node* top = Compile::current()-&gt;top();
1254   for (uint i = 0; i &lt; grow_by; i++) {
1255     ins_req(monoff, top);
1256   }
1257   jvms-&gt;set_monoff(monoff + grow_by);
1258   jvms-&gt;set_scloff(scloff + grow_by);
1259   jvms-&gt;set_endoff(endoff + grow_by);
1260 }
1261 
1262 void SafePointNode::push_monitor(const FastLockNode *lock) {
1263   // Add a LockNode, which points to both the original BoxLockNode (the
1264   // stack space for the monitor) and the Object being locked.
1265   const int MonitorEdges = 2;
1266   assert(JVMState::logMonitorEdges == exact_log2(MonitorEdges), &quot;correct MonitorEdges&quot;);
1267   assert(req() == jvms()-&gt;endoff(), &quot;correct sizing&quot;);
1268   int nextmon = jvms()-&gt;scloff();
1269   if (GenerateSynchronizationCode) {
1270     ins_req(nextmon,   lock-&gt;box_node());
1271     ins_req(nextmon+1, lock-&gt;obj_node());
1272   } else {
1273     Node* top = Compile::current()-&gt;top();
1274     ins_req(nextmon, top);
1275     ins_req(nextmon, top);
1276   }
1277   jvms()-&gt;set_scloff(nextmon + MonitorEdges);
1278   jvms()-&gt;set_endoff(req());
1279 }
1280 
1281 void SafePointNode::pop_monitor() {
1282   // Delete last monitor from debug info
1283   debug_only(int num_before_pop = jvms()-&gt;nof_monitors());
1284   const int MonitorEdges = 2;
1285   assert(JVMState::logMonitorEdges == exact_log2(MonitorEdges), &quot;correct MonitorEdges&quot;);
1286   int scloff = jvms()-&gt;scloff();
1287   int endoff = jvms()-&gt;endoff();
1288   int new_scloff = scloff - MonitorEdges;
1289   int new_endoff = endoff - MonitorEdges;
1290   jvms()-&gt;set_scloff(new_scloff);
1291   jvms()-&gt;set_endoff(new_endoff);
1292   while (scloff &gt; new_scloff)  del_req_ordered(--scloff);
1293   assert(jvms()-&gt;nof_monitors() == num_before_pop-1, &quot;&quot;);
1294 }
1295 
1296 Node *SafePointNode::peek_monitor_box() const {
1297   int mon = jvms()-&gt;nof_monitors() - 1;
1298   assert(mon &gt;= 0, &quot;must have a monitor&quot;);
1299   return monitor_box(jvms(), mon);
1300 }
1301 
1302 Node *SafePointNode::peek_monitor_obj() const {
1303   int mon = jvms()-&gt;nof_monitors() - 1;
1304   assert(mon &gt;= 0, &quot;must have a monitor&quot;);
1305   return monitor_obj(jvms(), mon);
1306 }
1307 
1308 // Do we Match on this edge index or not?  Match no edges
1309 uint SafePointNode::match_edge(uint idx) const {
1310   return (TypeFunc::Parms == idx);
1311 }
1312 
1313 void SafePointNode::disconnect_from_root(PhaseIterGVN *igvn) {
1314   assert(Opcode() == Op_SafePoint, &quot;only value for safepoint in loops&quot;);
1315   int nb = igvn-&gt;C-&gt;root()-&gt;find_prec_edge(this);
1316   if (nb != -1) {
1317     igvn-&gt;C-&gt;root()-&gt;rm_prec(nb);
1318   }
1319 }
1320 
1321 //==============  SafePointScalarObjectNode  ==============
1322 
1323 SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp,
1324 #ifdef ASSERT
1325                                                      AllocateNode* alloc,
1326 #endif
1327                                                      uint first_index,
1328                                                      uint n_fields) :
1329   TypeNode(tp, 1), // 1 control input -- seems required.  Get from root.
1330   _first_index(first_index),
<a name="8" id="anc8"></a><span class="line-modified">1331   _n_fields(n_fields),</span>
<span class="line-added">1332   _is_stack_allocated(false)</span>
1333 #ifdef ASSERT
1334   , _alloc(alloc)
1335 #endif
1336 {
1337   init_class_id(Class_SafePointScalarObject);
1338 }
1339 
1340 // Do not allow value-numbering for SafePointScalarObject node.
1341 uint SafePointScalarObjectNode::hash() const { return NO_HASH; }
1342 bool SafePointScalarObjectNode::cmp( const Node &amp;n ) const {
1343   return (&amp;n == this); // Always fail except on self
1344 }
1345 
1346 uint SafePointScalarObjectNode::ideal_reg() const {
1347   return 0; // No matching to machine instruction
1348 }
1349 
1350 const RegMask &amp;SafePointScalarObjectNode::in_RegMask(uint idx) const {
1351   return *(Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()]);
1352 }
1353 
1354 const RegMask &amp;SafePointScalarObjectNode::out_RegMask() const {
1355   return RegMask::Empty;
1356 }
1357 
1358 uint SafePointScalarObjectNode::match_edge(uint idx) const {
1359   return 0;
1360 }
1361 
1362 SafePointScalarObjectNode*
1363 SafePointScalarObjectNode::clone(Dict* sosn_map) const {
1364   void* cached = (*sosn_map)[(void*)this];
1365   if (cached != NULL) {
1366     return (SafePointScalarObjectNode*)cached;
1367   }
1368   SafePointScalarObjectNode* res = (SafePointScalarObjectNode*)Node::clone();
1369   sosn_map-&gt;Insert((void*)this, (void*)res);
1370   return res;
1371 }
1372 
1373 
1374 #ifndef PRODUCT
1375 void SafePointScalarObjectNode::dump_spec(outputStream *st) const {
1376   st-&gt;print(&quot; # fields@[%d..%d]&quot;, first_index(),
1377              first_index() + n_fields() - 1);
1378 }
1379 
1380 #endif
1381 
1382 //=============================================================================
1383 uint AllocateNode::size_of() const { return sizeof(*this); }
1384 
1385 AllocateNode::AllocateNode(Compile* C, const TypeFunc *atype,
1386                            Node *ctrl, Node *mem, Node *abio,
1387                            Node *size, Node *klass_node, Node *initial_test)
1388   : CallNode(atype, NULL, TypeRawPtr::BOTTOM)
1389 {
1390   init_class_id(Class_Allocate);
1391   init_flags(Flag_is_macro);
1392   _is_scalar_replaceable = false;
1393   _is_non_escaping = false;
<a name="9" id="anc9"></a><span class="line-added">1394   _is_stack_allocateable = false;</span>
<span class="line-added">1395   _is_referenced_stack_allocation = false;</span>
1396   _is_allocation_MemBar_redundant = false;
1397   Node *topnode = C-&gt;top();
1398 
1399   init_req( TypeFunc::Control  , ctrl );
1400   init_req( TypeFunc::I_O      , abio );
1401   init_req( TypeFunc::Memory   , mem );
1402   init_req( TypeFunc::ReturnAdr, topnode );
1403   init_req( TypeFunc::FramePtr , topnode );
1404   init_req( AllocSize          , size);
1405   init_req( KlassNode          , klass_node);
1406   init_req( InitialTest        , initial_test);
1407   init_req( ALength            , topnode);
1408   C-&gt;add_macro_node(this);
1409 }
1410 
1411 void AllocateNode::compute_MemBar_redundancy(ciMethod* initializer)
1412 {
1413   assert(initializer != NULL &amp;&amp;
1414          initializer-&gt;is_initializer() &amp;&amp;
1415          !initializer-&gt;is_static(),
1416              &quot;unexpected initializer method&quot;);
1417   BCEscapeAnalyzer* analyzer = initializer-&gt;get_bcea();
1418   if (analyzer == NULL) {
1419     return;
1420   }
1421 
1422   // Allocation node is first parameter in its initializer
1423   if (analyzer-&gt;is_arg_stack(0) || analyzer-&gt;is_arg_local(0)) {
1424     _is_allocation_MemBar_redundant = true;
1425   }
1426 }
1427 Node *AllocateNode::make_ideal_mark(PhaseGVN *phase, Node* obj, Node* control, Node* mem) {
1428   Node* mark_node = NULL;
1429   // For now only enable fast locking for non-array types
1430   if (UseBiasedLocking &amp;&amp; Opcode() == Op_Allocate) {
1431     Node* klass_node = in(AllocateNode::KlassNode);
1432     Node* proto_adr = phase-&gt;transform(new AddPNode(klass_node, klass_node, phase-&gt;MakeConX(in_bytes(Klass::prototype_header_offset()))));
1433     mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
1434   } else {
1435     mark_node = phase-&gt;MakeConX(markWord::prototype().value());
1436   }
1437   return mark_node;
1438 }
1439 
1440 //=============================================================================
1441 Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1442   if (remove_dead_region(phase, can_reshape))  return this;
1443   // Don&#39;t bother trying to transform a dead node
1444   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
1445 
1446   const Type* type = phase-&gt;type(Ideal_length());
1447   if (type-&gt;isa_int() &amp;&amp; type-&gt;is_int()-&gt;_hi &lt; 0) {
1448     if (can_reshape) {
1449       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1450       // Unreachable fall through path (negative array length),
1451       // the allocation can only throw so disconnect it.
1452       Node* proj = proj_out_or_null(TypeFunc::Control);
1453       Node* catchproj = NULL;
1454       if (proj != NULL) {
1455         for (DUIterator_Fast imax, i = proj-&gt;fast_outs(imax); i &lt; imax; i++) {
1456           Node *cn = proj-&gt;fast_out(i);
1457           if (cn-&gt;is_Catch()) {
1458             catchproj = cn-&gt;as_Multi()-&gt;proj_out_or_null(CatchProjNode::fall_through_index);
1459             break;
1460           }
1461         }
1462       }
1463       if (catchproj != NULL &amp;&amp; catchproj-&gt;outcnt() &gt; 0 &amp;&amp;
1464           (catchproj-&gt;outcnt() &gt; 1 ||
1465            catchproj-&gt;unique_out()-&gt;Opcode() != Op_Halt)) {
1466         assert(catchproj-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
1467         Node* nproj = catchproj-&gt;clone();
1468         igvn-&gt;register_new_node_with_optimizer(nproj);
1469 
1470         Node *frame = new ParmNode( phase-&gt;C-&gt;start(), TypeFunc::FramePtr );
1471         frame = phase-&gt;transform(frame);
1472         // Halt &amp; Catch Fire
1473         Node* halt = new HaltNode(nproj, frame, &quot;unexpected negative array length&quot;);
1474         phase-&gt;C-&gt;root()-&gt;add_req(halt);
1475         phase-&gt;transform(halt);
1476 
1477         igvn-&gt;replace_node(catchproj, phase-&gt;C-&gt;top());
1478         return this;
1479       }
1480     } else {
1481       // Can&#39;t correct it during regular GVN so register for IGVN
1482       phase-&gt;C-&gt;record_for_igvn(this);
1483     }
1484   }
1485   return NULL;
1486 }
1487 
1488 // Retrieve the length from the AllocateArrayNode. Narrow the type with a
1489 // CastII, if appropriate.  If we are not allowed to create new nodes, and
1490 // a CastII is appropriate, return NULL.
1491 Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseTransform *phase, bool allow_new_nodes) {
1492   Node *length = in(AllocateNode::ALength);
1493   assert(length != NULL, &quot;length is not null&quot;);
1494 
1495   const TypeInt* length_type = phase-&gt;find_int_type(length);
1496   const TypeAryPtr* ary_type = oop_type-&gt;isa_aryptr();
1497 
1498   if (ary_type != NULL &amp;&amp; length_type != NULL) {
1499     const TypeInt* narrow_length_type = ary_type-&gt;narrow_size_type(length_type);
1500     if (narrow_length_type != length_type) {
1501       // Assert one of:
1502       //   - the narrow_length is 0
1503       //   - the narrow_length is not wider than length
1504       assert(narrow_length_type == TypeInt::ZERO ||
1505              length_type-&gt;is_con() &amp;&amp; narrow_length_type-&gt;is_con() &amp;&amp;
1506                 (narrow_length_type-&gt;_hi &lt;= length_type-&gt;_lo) ||
1507              (narrow_length_type-&gt;_hi &lt;= length_type-&gt;_hi &amp;&amp;
1508               narrow_length_type-&gt;_lo &gt;= length_type-&gt;_lo),
1509              &quot;narrow type must be narrower than length type&quot;);
1510 
1511       // Return NULL if new nodes are not allowed
1512       if (!allow_new_nodes) return NULL;
1513       // Create a cast which is control dependent on the initialization to
1514       // propagate the fact that the array length must be positive.
1515       InitializeNode* init = initialization();
1516       assert(init != NULL, &quot;initialization not found&quot;);
1517       length = new CastIINode(length, narrow_length_type);
1518       length-&gt;set_req(0, init-&gt;proj_out_or_null(0));
1519     }
1520   }
1521 
1522   return length;
1523 }
1524 
1525 //=============================================================================
1526 uint LockNode::size_of() const { return sizeof(*this); }
1527 
1528 // Redundant lock elimination
1529 //
1530 // There are various patterns of locking where we release and
1531 // immediately reacquire a lock in a piece of code where no operations
1532 // occur in between that would be observable.  In those cases we can
1533 // skip releasing and reacquiring the lock without violating any
1534 // fairness requirements.  Doing this around a loop could cause a lock
1535 // to be held for a very long time so we concentrate on non-looping
1536 // control flow.  We also require that the operations are fully
1537 // redundant meaning that we don&#39;t introduce new lock operations on
1538 // some paths so to be able to eliminate it on others ala PRE.  This
1539 // would probably require some more extensive graph manipulation to
1540 // guarantee that the memory edges were all handled correctly.
1541 //
1542 // Assuming p is a simple predicate which can&#39;t trap in any way and s
1543 // is a synchronized method consider this code:
1544 //
1545 //   s();
1546 //   if (p)
1547 //     s();
1548 //   else
1549 //     s();
1550 //   s();
1551 //
1552 // 1. The unlocks of the first call to s can be eliminated if the
1553 // locks inside the then and else branches are eliminated.
1554 //
1555 // 2. The unlocks of the then and else branches can be eliminated if
1556 // the lock of the final call to s is eliminated.
1557 //
1558 // Either of these cases subsumes the simple case of sequential control flow
1559 //
1560 // Addtionally we can eliminate versions without the else case:
1561 //
1562 //   s();
1563 //   if (p)
1564 //     s();
1565 //   s();
1566 //
1567 // 3. In this case we eliminate the unlock of the first s, the lock
1568 // and unlock in the then case and the lock in the final s.
1569 //
1570 // Note also that in all these cases the then/else pieces don&#39;t have
1571 // to be trivial as long as they begin and end with synchronization
1572 // operations.
1573 //
1574 //   s();
1575 //   if (p)
1576 //     s();
1577 //     f();
1578 //     s();
1579 //   s();
1580 //
1581 // The code will work properly for this case, leaving in the unlock
1582 // before the call to f and the relock after it.
1583 //
1584 // A potentially interesting case which isn&#39;t handled here is when the
1585 // locking is partially redundant.
1586 //
1587 //   s();
1588 //   if (p)
1589 //     s();
1590 //
1591 // This could be eliminated putting unlocking on the else case and
1592 // eliminating the first unlock and the lock in the then side.
1593 // Alternatively the unlock could be moved out of the then side so it
1594 // was after the merge and the first unlock and second lock
1595 // eliminated.  This might require less manipulation of the memory
1596 // state to get correct.
1597 //
1598 // Additionally we might allow work between a unlock and lock before
1599 // giving up eliminating the locks.  The current code disallows any
1600 // conditional control flow between these operations.  A formulation
1601 // similar to partial redundancy elimination computing the
1602 // availability of unlocking and the anticipatability of locking at a
1603 // program point would allow detection of fully redundant locking with
1604 // some amount of work in between.  I&#39;m not sure how often I really
1605 // think that would occur though.  Most of the cases I&#39;ve seen
1606 // indicate it&#39;s likely non-trivial work would occur in between.
1607 // There may be other more complicated constructs where we could
1608 // eliminate locking but I haven&#39;t seen any others appear as hot or
1609 // interesting.
1610 //
1611 // Locking and unlocking have a canonical form in ideal that looks
1612 // roughly like this:
1613 //
1614 //              &lt;obj&gt;
1615 //                | \\------+
1616 //                |  \       \
1617 //                | BoxLock   \
1618 //                |  |   |     \
1619 //                |  |    \     \
1620 //                |  |   FastLock
1621 //                |  |   /
1622 //                |  |  /
1623 //                |  |  |
1624 //
1625 //               Lock
1626 //                |
1627 //            Proj #0
1628 //                |
1629 //            MembarAcquire
1630 //                |
1631 //            Proj #0
1632 //
1633 //            MembarRelease
1634 //                |
1635 //            Proj #0
1636 //                |
1637 //              Unlock
1638 //                |
1639 //            Proj #0
1640 //
1641 //
1642 // This code proceeds by processing Lock nodes during PhaseIterGVN
1643 // and searching back through its control for the proper code
1644 // patterns.  Once it finds a set of lock and unlock operations to
1645 // eliminate they are marked as eliminatable which causes the
1646 // expansion of the Lock and Unlock macro nodes to make the operation a NOP
1647 //
1648 //=============================================================================
1649 
1650 //
1651 // Utility function to skip over uninteresting control nodes.  Nodes skipped are:
1652 //   - copy regions.  (These may not have been optimized away yet.)
1653 //   - eliminated locking nodes
1654 //
1655 static Node *next_control(Node *ctrl) {
1656   if (ctrl == NULL)
1657     return NULL;
1658   while (1) {
1659     if (ctrl-&gt;is_Region()) {
1660       RegionNode *r = ctrl-&gt;as_Region();
1661       Node *n = r-&gt;is_copy();
1662       if (n == NULL)
1663         break;  // hit a region, return it
1664       else
1665         ctrl = n;
1666     } else if (ctrl-&gt;is_Proj()) {
1667       Node *in0 = ctrl-&gt;in(0);
1668       if (in0-&gt;is_AbstractLock() &amp;&amp; in0-&gt;as_AbstractLock()-&gt;is_eliminated()) {
1669         ctrl = in0-&gt;in(0);
1670       } else {
1671         break;
1672       }
1673     } else {
1674       break; // found an interesting control
1675     }
1676   }
1677   return ctrl;
1678 }
1679 //
1680 // Given a control, see if it&#39;s the control projection of an Unlock which
1681 // operating on the same object as lock.
1682 //
1683 bool AbstractLockNode::find_matching_unlock(const Node* ctrl, LockNode* lock,
1684                                             GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops) {
1685   ProjNode *ctrl_proj = (ctrl-&gt;is_Proj()) ? ctrl-&gt;as_Proj() : NULL;
1686   if (ctrl_proj != NULL &amp;&amp; ctrl_proj-&gt;_con == TypeFunc::Control) {
1687     Node *n = ctrl_proj-&gt;in(0);
1688     if (n != NULL &amp;&amp; n-&gt;is_Unlock()) {
1689       UnlockNode *unlock = n-&gt;as_Unlock();
1690       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1691       Node* lock_obj = bs-&gt;step_over_gc_barrier(lock-&gt;obj_node());
1692       Node* unlock_obj = bs-&gt;step_over_gc_barrier(unlock-&gt;obj_node());
1693       if (lock_obj-&gt;eqv_uncast(unlock_obj) &amp;&amp;
1694           BoxLockNode::same_slot(lock-&gt;box_node(), unlock-&gt;box_node()) &amp;&amp;
1695           !unlock-&gt;is_eliminated()) {
1696         lock_ops.append(unlock);
1697         return true;
1698       }
1699     }
1700   }
1701   return false;
1702 }
1703 
1704 //
1705 // Find the lock matching an unlock.  Returns null if a safepoint
1706 // or complicated control is encountered first.
1707 LockNode *AbstractLockNode::find_matching_lock(UnlockNode* unlock) {
1708   LockNode *lock_result = NULL;
1709   // find the matching lock, or an intervening safepoint
1710   Node *ctrl = next_control(unlock-&gt;in(0));
1711   while (1) {
1712     assert(ctrl != NULL, &quot;invalid control graph&quot;);
1713     assert(!ctrl-&gt;is_Start(), &quot;missing lock for unlock&quot;);
1714     if (ctrl-&gt;is_top()) break;  // dead control path
1715     if (ctrl-&gt;is_Proj()) ctrl = ctrl-&gt;in(0);
1716     if (ctrl-&gt;is_SafePoint()) {
1717         break;  // found a safepoint (may be the lock we are searching for)
1718     } else if (ctrl-&gt;is_Region()) {
1719       // Check for a simple diamond pattern.  Punt on anything more complicated
1720       if (ctrl-&gt;req() == 3 &amp;&amp; ctrl-&gt;in(1) != NULL &amp;&amp; ctrl-&gt;in(2) != NULL) {
1721         Node *in1 = next_control(ctrl-&gt;in(1));
1722         Node *in2 = next_control(ctrl-&gt;in(2));
1723         if (((in1-&gt;is_IfTrue() &amp;&amp; in2-&gt;is_IfFalse()) ||
1724              (in2-&gt;is_IfTrue() &amp;&amp; in1-&gt;is_IfFalse())) &amp;&amp; (in1-&gt;in(0) == in2-&gt;in(0))) {
1725           ctrl = next_control(in1-&gt;in(0)-&gt;in(0));
1726         } else {
1727           break;
1728         }
1729       } else {
1730         break;
1731       }
1732     } else {
1733       ctrl = next_control(ctrl-&gt;in(0));  // keep searching
1734     }
1735   }
1736   if (ctrl-&gt;is_Lock()) {
1737     LockNode *lock = ctrl-&gt;as_Lock();
1738     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1739     Node* lock_obj = bs-&gt;step_over_gc_barrier(lock-&gt;obj_node());
1740     Node* unlock_obj = bs-&gt;step_over_gc_barrier(unlock-&gt;obj_node());
1741     if (lock_obj-&gt;eqv_uncast(unlock_obj) &amp;&amp;
1742         BoxLockNode::same_slot(lock-&gt;box_node(), unlock-&gt;box_node())) {
1743       lock_result = lock;
1744     }
1745   }
1746   return lock_result;
1747 }
1748 
1749 // This code corresponds to case 3 above.
1750 
1751 bool AbstractLockNode::find_lock_and_unlock_through_if(Node* node, LockNode* lock,
1752                                                        GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops) {
1753   Node* if_node = node-&gt;in(0);
1754   bool  if_true = node-&gt;is_IfTrue();
1755 
1756   if (if_node-&gt;is_If() &amp;&amp; if_node-&gt;outcnt() == 2 &amp;&amp; (if_true || node-&gt;is_IfFalse())) {
1757     Node *lock_ctrl = next_control(if_node-&gt;in(0));
1758     if (find_matching_unlock(lock_ctrl, lock, lock_ops)) {
1759       Node* lock1_node = NULL;
1760       ProjNode* proj = if_node-&gt;as_If()-&gt;proj_out(!if_true);
1761       if (if_true) {
1762         if (proj-&gt;is_IfFalse() &amp;&amp; proj-&gt;outcnt() == 1) {
1763           lock1_node = proj-&gt;unique_out();
1764         }
1765       } else {
1766         if (proj-&gt;is_IfTrue() &amp;&amp; proj-&gt;outcnt() == 1) {
1767           lock1_node = proj-&gt;unique_out();
1768         }
1769       }
1770       if (lock1_node != NULL &amp;&amp; lock1_node-&gt;is_Lock()) {
1771         LockNode *lock1 = lock1_node-&gt;as_Lock();
1772         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1773         Node* lock_obj = bs-&gt;step_over_gc_barrier(lock-&gt;obj_node());
1774         Node* lock1_obj = bs-&gt;step_over_gc_barrier(lock1-&gt;obj_node());
1775         if (lock_obj-&gt;eqv_uncast(lock1_obj) &amp;&amp;
1776             BoxLockNode::same_slot(lock-&gt;box_node(), lock1-&gt;box_node()) &amp;&amp;
1777             !lock1-&gt;is_eliminated()) {
1778           lock_ops.append(lock1);
1779           return true;
1780         }
1781       }
1782     }
1783   }
1784 
1785   lock_ops.trunc_to(0);
1786   return false;
1787 }
1788 
1789 bool AbstractLockNode::find_unlocks_for_region(const RegionNode* region, LockNode* lock,
1790                                GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops) {
1791   // check each control merging at this point for a matching unlock.
1792   // in(0) should be self edge so skip it.
1793   for (int i = 1; i &lt; (int)region-&gt;req(); i++) {
1794     Node *in_node = next_control(region-&gt;in(i));
1795     if (in_node != NULL) {
1796       if (find_matching_unlock(in_node, lock, lock_ops)) {
1797         // found a match so keep on checking.
1798         continue;
1799       } else if (find_lock_and_unlock_through_if(in_node, lock, lock_ops)) {
1800         continue;
1801       }
1802 
1803       // If we fall through to here then it was some kind of node we
1804       // don&#39;t understand or there wasn&#39;t a matching unlock, so give
1805       // up trying to merge locks.
1806       lock_ops.trunc_to(0);
1807       return false;
1808     }
1809   }
1810   return true;
1811 
1812 }
1813 
1814 #ifndef PRODUCT
1815 //
1816 // Create a counter which counts the number of times this lock is acquired
1817 //
1818 void AbstractLockNode::create_lock_counter(JVMState* state) {
1819   _counter = OptoRuntime::new_named_counter(state, NamedCounter::LockCounter);
1820 }
1821 
1822 void AbstractLockNode::set_eliminated_lock_counter() {
1823   if (_counter) {
1824     // Update the counter to indicate that this lock was eliminated.
1825     // The counter update code will stay around even though the
1826     // optimizer will eliminate the lock operation itself.
1827     _counter-&gt;set_tag(NamedCounter::EliminatedLockCounter);
1828   }
1829 }
1830 
1831 const char* AbstractLockNode::_kind_names[] = {&quot;Regular&quot;, &quot;NonEscObj&quot;, &quot;Coarsened&quot;, &quot;Nested&quot;};
1832 
1833 void AbstractLockNode::dump_spec(outputStream* st) const {
1834   st-&gt;print(&quot;%s &quot;, _kind_names[_kind]);
1835   CallNode::dump_spec(st);
1836 }
1837 
1838 void AbstractLockNode::dump_compact_spec(outputStream* st) const {
1839   st-&gt;print(&quot;%s&quot;, _kind_names[_kind]);
1840 }
1841 
1842 // The related set of lock nodes includes the control boundary.
1843 void AbstractLockNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1844   if (compact) {
1845       this-&gt;collect_nodes(in_rel, 1, false, false);
1846     } else {
1847       this-&gt;collect_nodes_in_all_data(in_rel, true);
1848     }
1849     this-&gt;collect_nodes(out_rel, -2, false, false);
1850 }
1851 #endif
1852 
1853 //=============================================================================
1854 Node *LockNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1855 
1856   // perform any generic optimizations first (returns &#39;this&#39; or NULL)
1857   Node *result = SafePointNode::Ideal(phase, can_reshape);
1858   if (result != NULL)  return result;
1859   // Don&#39;t bother trying to transform a dead node
1860   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
1861 
1862   // Now see if we can optimize away this lock.  We don&#39;t actually
1863   // remove the locking here, we simply set the _eliminate flag which
1864   // prevents macro expansion from expanding the lock.  Since we don&#39;t
1865   // modify the graph, the value returned from this function is the
1866   // one computed above.
1867   if (can_reshape &amp;&amp; EliminateLocks &amp;&amp; !is_non_esc_obj()) {
1868     //
1869     // If we are locking an unescaped object, the lock/unlock is unnecessary
1870     //
1871     ConnectionGraph *cgr = phase-&gt;C-&gt;congraph();
1872     if (cgr != NULL &amp;&amp; cgr-&gt;not_global_escape(obj_node())) {
1873       assert(!is_eliminated() || is_coarsened(), &quot;sanity&quot;);
1874       // The lock could be marked eliminated by lock coarsening
1875       // code during first IGVN before EA. Replace coarsened flag
1876       // to eliminate all associated locks/unlocks.
1877 #ifdef ASSERT
1878       this-&gt;log_lock_optimization(phase-&gt;C,&quot;eliminate_lock_set_non_esc1&quot;);
1879 #endif
1880       this-&gt;set_non_esc_obj();
1881       return result;
1882     }
1883 
1884     //
1885     // Try lock coarsening
1886     //
1887     PhaseIterGVN* iter = phase-&gt;is_IterGVN();
1888     if (iter != NULL &amp;&amp; !is_eliminated()) {
1889 
1890       GrowableArray&lt;AbstractLockNode*&gt;   lock_ops;
1891 
1892       Node *ctrl = next_control(in(0));
1893 
1894       // now search back for a matching Unlock
1895       if (find_matching_unlock(ctrl, this, lock_ops)) {
1896         // found an unlock directly preceding this lock.  This is the
1897         // case of single unlock directly control dependent on a
1898         // single lock which is the trivial version of case 1 or 2.
1899       } else if (ctrl-&gt;is_Region() ) {
1900         if (find_unlocks_for_region(ctrl-&gt;as_Region(), this, lock_ops)) {
1901         // found lock preceded by multiple unlocks along all paths
1902         // joining at this point which is case 3 in description above.
1903         }
1904       } else {
1905         // see if this lock comes from either half of an if and the
1906         // predecessors merges unlocks and the other half of the if
1907         // performs a lock.
1908         if (find_lock_and_unlock_through_if(ctrl, this, lock_ops)) {
1909           // found unlock splitting to an if with locks on both branches.
1910         }
1911       }
1912 
1913       if (lock_ops.length() &gt; 0) {
1914         // add ourselves to the list of locks to be eliminated.
1915         lock_ops.append(this);
1916 
1917   #ifndef PRODUCT
1918         if (PrintEliminateLocks) {
1919           int locks = 0;
1920           int unlocks = 0;
1921           for (int i = 0; i &lt; lock_ops.length(); i++) {
1922             AbstractLockNode* lock = lock_ops.at(i);
1923             if (lock-&gt;Opcode() == Op_Lock)
1924               locks++;
1925             else
1926               unlocks++;
1927             if (Verbose) {
1928               lock-&gt;dump(1);
1929             }
1930           }
1931           tty-&gt;print_cr(&quot;***Eliminated %d unlocks and %d locks&quot;, unlocks, locks);
1932         }
1933   #endif
1934 
1935         // for each of the identified locks, mark them
1936         // as eliminatable
1937         for (int i = 0; i &lt; lock_ops.length(); i++) {
1938           AbstractLockNode* lock = lock_ops.at(i);
1939 
1940           // Mark it eliminated by coarsening and update any counters
1941 #ifdef ASSERT
1942           lock-&gt;log_lock_optimization(phase-&gt;C, &quot;eliminate_lock_set_coarsened&quot;);
1943 #endif
1944           lock-&gt;set_coarsened();
1945         }
1946       } else if (ctrl-&gt;is_Region() &amp;&amp;
1947                  iter-&gt;_worklist.member(ctrl)) {
1948         // We weren&#39;t able to find any opportunities but the region this
1949         // lock is control dependent on hasn&#39;t been processed yet so put
1950         // this lock back on the worklist so we can check again once any
1951         // region simplification has occurred.
1952         iter-&gt;_worklist.push(this);
1953       }
1954     }
1955   }
1956 
1957   return result;
1958 }
1959 
1960 //=============================================================================
1961 bool LockNode::is_nested_lock_region() {
1962   return is_nested_lock_region(NULL);
1963 }
1964 
1965 // p is used for access to compilation log; no logging if NULL
1966 bool LockNode::is_nested_lock_region(Compile * c) {
1967   BoxLockNode* box = box_node()-&gt;as_BoxLock();
1968   int stk_slot = box-&gt;stack_slot();
1969   if (stk_slot &lt;= 0) {
1970 #ifdef ASSERT
1971     this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_1&quot;);
1972 #endif
1973     return false; // External lock or it is not Box (Phi node).
1974   }
1975 
1976   // Ignore complex cases: merged locks or multiple locks.
1977   Node* obj = obj_node();
1978   LockNode* unique_lock = NULL;
1979   if (!box-&gt;is_simple_lock_region(&amp;unique_lock, obj)) {
1980 #ifdef ASSERT
1981     this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_2a&quot;);
1982 #endif
1983     return false;
1984   }
1985   if (unique_lock != this) {
1986 #ifdef ASSERT
1987     this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_2b&quot;);
1988 #endif
1989     return false;
1990   }
1991 
1992   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1993   obj = bs-&gt;step_over_gc_barrier(obj);
1994   // Look for external lock for the same object.
1995   SafePointNode* sfn = this-&gt;as_SafePoint();
1996   JVMState* youngest_jvms = sfn-&gt;jvms();
1997   int max_depth = youngest_jvms-&gt;depth();
1998   for (int depth = 1; depth &lt;= max_depth; depth++) {
1999     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
2000     int num_mon  = jvms-&gt;nof_monitors();
2001     // Loop over monitors
2002     for (int idx = 0; idx &lt; num_mon; idx++) {
2003       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
2004       obj_node = bs-&gt;step_over_gc_barrier(obj_node);
2005       BoxLockNode* box_node = sfn-&gt;monitor_box(jvms, idx)-&gt;as_BoxLock();
2006       if ((box_node-&gt;stack_slot() &lt; stk_slot) &amp;&amp; obj_node-&gt;eqv_uncast(obj)) {
2007         return true;
2008       }
2009     }
2010   }
2011 #ifdef ASSERT
2012   this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_3&quot;);
2013 #endif
2014   return false;
2015 }
2016 
2017 //=============================================================================
2018 uint UnlockNode::size_of() const { return sizeof(*this); }
2019 
2020 //=============================================================================
2021 Node *UnlockNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2022 
2023   // perform any generic optimizations first (returns &#39;this&#39; or NULL)
2024   Node *result = SafePointNode::Ideal(phase, can_reshape);
2025   if (result != NULL)  return result;
2026   // Don&#39;t bother trying to transform a dead node
2027   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
2028 
2029   // Now see if we can optimize away this unlock.  We don&#39;t actually
2030   // remove the unlocking here, we simply set the _eliminate flag which
2031   // prevents macro expansion from expanding the unlock.  Since we don&#39;t
2032   // modify the graph, the value returned from this function is the
2033   // one computed above.
2034   // Escape state is defined after Parse phase.
2035   if (can_reshape &amp;&amp; EliminateLocks &amp;&amp; !is_non_esc_obj()) {
2036     //
2037     // If we are unlocking an unescaped object, the lock/unlock is unnecessary.
2038     //
2039     ConnectionGraph *cgr = phase-&gt;C-&gt;congraph();
2040     if (cgr != NULL &amp;&amp; cgr-&gt;not_global_escape(obj_node())) {
2041       assert(!is_eliminated() || is_coarsened(), &quot;sanity&quot;);
2042       // The lock could be marked eliminated by lock coarsening
2043       // code during first IGVN before EA. Replace coarsened flag
2044       // to eliminate all associated locks/unlocks.
2045 #ifdef ASSERT
2046       this-&gt;log_lock_optimization(phase-&gt;C, &quot;eliminate_lock_set_non_esc2&quot;);
2047 #endif
2048       this-&gt;set_non_esc_obj();
2049     }
2050   }
2051   return result;
2052 }
2053 
2054 const char * AbstractLockNode::kind_as_string() const {
2055   return is_coarsened()   ? &quot;coarsened&quot; :
2056          is_nested()      ? &quot;nested&quot; :
2057          is_non_esc_obj() ? &quot;non_escaping&quot; :
2058          &quot;?&quot;;
2059 }
2060 
2061 void AbstractLockNode::log_lock_optimization(Compile *C, const char * tag)  const {
2062   if (C == NULL) {
2063     return;
2064   }
2065   CompileLog* log = C-&gt;log();
2066   if (log != NULL) {
2067     log-&gt;begin_head(&quot;%s lock=&#39;%d&#39; compile_id=&#39;%d&#39; class_id=&#39;%s&#39; kind=&#39;%s&#39;&quot;,
2068           tag, is_Lock(), C-&gt;compile_id(),
2069           is_Unlock() ? &quot;unlock&quot; : is_Lock() ? &quot;lock&quot; : &quot;?&quot;,
2070           kind_as_string());
2071     log-&gt;stamp();
2072     log-&gt;end_head();
2073     JVMState* p = is_Unlock() ? (as_Unlock()-&gt;dbg_jvms()) : jvms();
2074     while (p != NULL) {
2075       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
2076       p = p-&gt;caller();
2077     }
2078     log-&gt;tail(tag);
2079   }
2080 }
2081 
2082 bool CallNode::may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr *t_oop, PhaseTransform *phase) {
2083   if (dest_t-&gt;is_known_instance() &amp;&amp; t_oop-&gt;is_known_instance()) {
2084     return dest_t-&gt;instance_id() == t_oop-&gt;instance_id();
2085   }
2086 
2087   if (dest_t-&gt;isa_instptr() &amp;&amp; !dest_t-&gt;klass()-&gt;equals(phase-&gt;C-&gt;env()-&gt;Object_klass())) {
2088     // clone
2089     if (t_oop-&gt;isa_aryptr()) {
2090       return false;
2091     }
2092     if (!t_oop-&gt;isa_instptr()) {
2093       return true;
2094     }
2095     if (dest_t-&gt;klass()-&gt;is_subtype_of(t_oop-&gt;klass()) || t_oop-&gt;klass()-&gt;is_subtype_of(dest_t-&gt;klass())) {
2096       return true;
2097     }
2098     // unrelated
2099     return false;
2100   }
2101 
2102   if (dest_t-&gt;isa_aryptr()) {
2103     // arraycopy or array clone
2104     if (t_oop-&gt;isa_instptr()) {
2105       return false;
2106     }
2107     if (!t_oop-&gt;isa_aryptr()) {
2108       return true;
2109     }
2110 
2111     const Type* elem = dest_t-&gt;is_aryptr()-&gt;elem();
2112     if (elem == Type::BOTTOM) {
2113       // An array but we don&#39;t know what elements are
2114       return true;
2115     }
2116 
2117     dest_t = dest_t-&gt;add_offset(Type::OffsetBot)-&gt;is_oopptr();
2118     uint dest_alias = phase-&gt;C-&gt;get_alias_index(dest_t);
2119     uint t_oop_alias = phase-&gt;C-&gt;get_alias_index(t_oop);
2120 
2121     return dest_alias == t_oop_alias;
2122   }
2123 
2124   return true;
2125 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>